import * as dotenv from 'dotenv'
import * as fs from 'fs'
import fetch from 'node-fetch'

dotenv.config();

// This is the main file for the Netlify Build plugin netlfycommercetools-frontend.
// Please read the comments to learn more about the Netlify Build plugin syntax.
// Find more information in the Netlify documentation.

/* eslint-disable no-unused-vars */
// The plugin main logic uses `on...` event handlers that are triggered on
// each new Netlify Build.
// Anything can be done inside those event handlers.
// Information about the current build are passed as arguments. The build
// configuration file and some core utilities are also available.
export const onPreBuild = async function ({
  // Whole configuration file. For example, content of `netlify.toml`
  netlifyConfig,
  // Users can pass configuration inputs to any plugin in their Netlify
  // configuration file.
  // For example:
  //
  //   [[plugins]]
  //   package = "netlify-plugin-netlfycommercetools-frontend"
  //     [plugins.inputs]
  //     foo = "bar"
  inputs,
  // `onError` event handlers receive the error instance as argument
  error,

  // Build constants
  constants: {
    // Path to the Netlify configuration file. `undefined` if none was used
    CONFIG_PATH,
    // Directory that contains the deploy-ready HTML files and assets
    // generated by the build. Its value is always defined, but the target
    // might not have been created yet.
    PUBLISH_DIR,
    // The directory where function source code lives.
    // `undefined` if not specified by the user.
    FUNCTIONS_SRC,
    // The directory where built serverless functions are placed before
    // deployment. Its value is always defined, but the target might not have
    // been created yet.
    FUNCTIONS_DIST,
    // Boolean indicating whether the build was run locally (Netlify CLI) or
    // in the production CI
    IS_LOCAL,
    // Version of Netlify Build as a `major.minor.patch` string
    NETLIFY_BUILD_VERSION,
    // The Netlify Site ID
    SITE_ID,
  },

  // Core utilities
  utils: {
    // Utility to report errors.
    // See https://github.com/netlify/build#error-reporting
    build,
    // Utility to display information in the deploy summary.
    // See https://github.com/netlify/build#logging
    status,
    // Utility for caching files.
    // See https://github.com/netlify/build/blob/master/packages/cache-utils#readme
    cache,
    // Utility for running commands.
    // See https://github.com/netlify/build/blob/master/packages/run-utils#readme
    run,
    // Utility for dealing with modified, created, deleted files since a git commit.
    // See https://github.com/netlify/build/blob/master/packages/git-utils#readme
    git,
    // Utility for handling Netlify Functions.
    // See https://github.com/netlify/build/tree/master/packages/functions-utils#readme
    functions,
  },
}) {
  try {
    // Commands are printed in Netlify logs
	  const shortCommitHash = process.env.COMMIT_REF.substring(0, 7)
    	  fs.writeFileSync(".env.production.local", `NEXT_PUBLIC_EXT_BUILD_ID=${shortCommitHash}`)
	  await waitForBackend(shortCommitHash)
  } catch (error) {
    // Report a user error
    build.failBuild('Error message', { error })
  }

  // Console logs are shown in Netlify logs
  console.log('Netlify configuration', netlifyConfig)
  console.log('Plugin configuration', inputs)
  console.log('Build directory', PUBLISH_DIR)

  // Display success information
  status.show({ summary: 'Success!' })
}

// Other available event handlers
/*

// Before build commands are executed
export const onPreBuild = function () {}

// Build commands are executed
export const onBuild = function () {}

// After Build commands are executed
export const onPostBuild = function () {}

// Runs on build success
export const onSuccess = function () {}

// Runs on build error
export const onError = function () {}

// Runs on build error or success
export const onEnd = function () {}

*/



const checkBackend = async (version) => {
    // hacky!
    if (!process.env.NEXT_PUBLIC_FRONTASTIC_HOST) {
	    return true;
    }

    const path = process.env.NEXT_PUBLIC_FRONTASTIC_HOST + '/status/extensionrunner'
    console.log("Calling " + path, "Version " + version)
    const actualInit = {
        headers: {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'Commercetools-Frontend-Extension-Version': version,
        },
    };

    return await fetch(path, actualInit).then(async response => {
        const responseObj = await response.json()
        console.log("Extension response: ", responseObj)
        return responseObj.up
    })
}

const waitForBackend = async (shortCommitHash) => {
    for (let i = 0; i < 35; i++) {
        const attempt = i + 1
        console.log("Checking if extension is up, attempt: ", attempt)
        const up = await checkBackend(shortCommitHash);
        if (!up) {
            console.error("Extension is not available, waiting for", attempt, "seconds")
	    await sleep(i * 1000)
        } else {
            console.log("Extension is up!")
            return
        }
    }

    throw new Error("Extension is not up")
}

const sleep = (ms) => {
	return new Promise(resolve => setTimeout(resolve, ms))
}
